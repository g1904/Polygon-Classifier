# -*- coding: utf-8 -*-
"""HoningNetwork.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M38klOwOPfqujOcG5aEDdyjiwfYkz8bo
"""

import tensorflow as tf
import cv2 as cv
from google.colab.patches import cv2_imshow
import numpy as np
from matplotlib import pyplot as plt
from keras import models
from keras import layers
from keras.callbacks import  EarlyStopping
from tensorflow.keras.preprocessing import image_dataset_from_directory
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.data import Dataset
import tensorflow_datasets as tfds
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns

def load_dataset(SHOULD_USE_ARTIFICIAL_DATA = False):
  # load dataset
  (x_train, y_train), (x_test, y_test) = (None, None), (None, None)
  if SHOULD_USE_ARTIFICIAL_DATA:
    datagen = tf.keras.preprocessing.image.ImageDataGenerator(rescale = 1./255)
    train_ds = datagen.flow_from_directory(
    "datasets/artificial_mnist/images",
    target_size = (32,32),
    class_mode = "categorical",
    batch_size = 8,
    color_mode='grayscale'
    )
    test_ds = datagen.flow_from_directory(
    "datasets/test_mnist",
    target_size = (32,32),
    class_mode = "categorical",
    batch_size = 8,
    shuffle = False,
    color_mode='grayscale'
    )
    return train_ds, test_ds
  else:
    (x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()
    # reshape dataset to have a single channel
    x_train = x_train.reshape((x_train.shape[0], 28, 28, 1))
    x_test = x_test.reshape((x_test.shape[0], 28, 28, 1))
    # one hot encode target values
    y_train = tf.keras.utils.to_categorical(y_train)
    y_test = tf.keras.utils.to_categorical(y_test)
    return x_train, y_train, x_test, y_test

def prep_pixels(train, test):
	# normalize to range 0-1
  train_norm = train.astype('float32') / 255.0
  test_norm = test.astype('float32') / 255.0
	# return normalized images

  return train_norm, test_norm

train_ds, test_ds = load_dataset(True)

def create_model():
  model = tf.keras.Sequential()
  model.add(layers.Conv2D(filters=6, kernel_size=(3, 3), activation='relu'))
  model.add(layers.AveragePooling2D())

  model.add(layers.Conv2D(filters=16, kernel_size=(3, 3), activation='relu'))
  model.add(layers.AveragePooling2D())

  model.add(layers.Flatten())

  model.add(layers.Dense(units=120, activation='relu'))

  model.add(layers.Dense(units=84, activation='relu'))

  model.add(layers.Dense(units=10, activation = 'softmax'))
  return model

pretrained_model = create_model()

pretrained_model.build(input_shape=(None,32,32,1))

pretrained_model.compile(loss=tf.keras.losses.categorical_crossentropy, optimizer=tf.keras.optimizers.Adam(0.001), metrics=['accuracy'])

pretrained_model.summary()

es = EarlyStopping(monitor='loss', mode = "min", patience=3)

pretrained_model.fit(train_ds,
          epochs = 5,
          validation_data=test_ds,
          callbacks = [es])

actual_x_train, actual_y_train, actual_x_test, actual_y_test = load_dataset(False)

actual_x_train = actual_x_train[0:5000]
actual_y_train = actual_y_train[0:5000]

actual_x_train, actual_x_test = prep_pixels(actual_x_train,actual_x_test)

# Pad images with 0s
actual_x_train = np.pad(actual_x_train, ((0,0),(2,2),(2,2),(0,0)), 'constant')
actual_x_test = np.pad(actual_x_test, ((0,0),(2,2),(2,2),(0,0)), 'constant')

pretrained_model.fit(actual_x_train,
          actual_y_train,
          epochs = 20,
          validation_data=(actual_x_test,actual_y_test),
          callbacks = [es])

def plot_confusion_matrix(x_test, y_test, model):
  predictions = model.predict_classes(x_test)
  y_test = np.argmax(y_test, axis =1)
  cm = confusion_matrix(y_test, predictions)
  class_labels = list([0,1,2,3,4,5,6,7,8,9])
  fig = plt.figure(figsize = (8,8))
  ax1 = fig.add_subplot(1,1,1)
  sns.set(font_scale=1.4) #for label size
  sns.heatmap(cm, annot=True, annot_kws={"size": 12}, cmap='Blues',fmt='g');
  ax1.set_ylabel('True Values',fontsize=14)
  ax1.set_xlabel('Predicted Values',fontsize=14)
  ax1.set_xticklabels(class_labels)
  ax1.set_yticklabels(class_labels, rotation = "horizontal")
  plt.show()

plot_confusion_matrix(actual_x_test, actual_y_test, pretrained_model)

pretrained_model.evaluate(actual_x_test,actual_y_test)